<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DTLS v1.3 Implementation: SystemC Architecture Documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DTLS v1.3 Implementation<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">Production-ready DTLS v1.3 implementation with RFC 9147 compliance and quantum-resistant cryptography</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_docs_2SYSTEMC__ARCHITECTURE.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">SystemC Architecture Documentation</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md887"></a> </p>
<h1><a class="anchor" id="autotoc_md888"></a>
Table of Contents</h1>
<ul>
<li>Overview</li>
<li>SystemC TLM Architecture</li>
<li>Core Protocol Separation Pattern</li>
<li>TLM Extensions Design</li>
<li>Timing Models Architecture</li>
<li>Communication Channels</li>
<li>Testbench Architecture</li>
<li>Performance Analysis Framework</li>
<li>Hardware/Software Co-design</li>
</ul>
<h1><a class="anchor" id="autotoc_md889"></a>
Overview</h1>
<p>The SystemC implementation of DTLS v1.3 provides a comprehensive Transaction Level Modeling (TLM) framework for hardware/software co-design, verification, and performance analysis. The architecture follows IEEE 1666 SystemC standards and TLM-2.0 compliance while providing DTLS-specific modeling capabilities.</p>
<h2><a class="anchor" id="autotoc_md890"></a>
Key SystemC Architecture Goals</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Goal   </th><th class="markdownTableHeadNone">Implementation   </th><th class="markdownTableHeadNone">Benefit    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>TLM-2.0 Compliance</b>   </td><td class="markdownTableBodyNone">Standard interfaces and protocols   </td><td class="markdownTableBodyNone">Tool interoperability    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Timing Accuracy</b>   </td><td class="markdownTableBodyNone">Configurable timing models   </td><td class="markdownTableBodyNone">Performance validation    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Protocol Modeling</b>   </td><td class="markdownTableBodyNone">DTLS-specific TLM extensions   </td><td class="markdownTableBodyNone">Accurate behavior modeling    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Verification</b>   </td><td class="markdownTableBodyNone">Comprehensive testbench infrastructure   </td><td class="markdownTableBodyNone">Design validation    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Performance Analysis</b>   </td><td class="markdownTableBodyNone">Detailed metrics and monitoring   </td><td class="markdownTableBodyNone">Optimization guidance   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md891"></a>
SystemC TLM Architecture</h1>
<h2><a class="anchor" id="autotoc_md892"></a>
High-Level SystemC Architecture</h2>
<div class="fragment"><div class="line">SystemC Environment</div>
<div class="line">┌─────────────────────────────────────────────────────────────┐</div>
<div class="line">│                   SystemC Testbench                        │</div>
<div class="line">│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐  │</div>
<div class="line">│  │ Traffic Gen  │    │  Monitor     │    │ Analysis     │  │</div>
<div class="line">│  │              │    │              │    │              │  │</div>
<div class="line">│  └──────────────┘    └──────────────┘    └──────────────┘  │</div>
<div class="line">├─────────────────────────────────────────────────────────────┤</div>
<div class="line">│                    TLM Protocol Level                      │</div>
<div class="line">│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐  │</div>
<div class="line">│  │ DTLS Client  │────│   Network    │────│ DTLS Server  │  │</div>
<div class="line">│  │  TLM Model   │    │   Channel    │    │  TLM Model   │  │</div>
<div class="line">│  └──────────────┘    └──────────────┘    └──────────────┘  │</div>
<div class="line">├─────────────────────────────────────────────────────────────┤</div>
<div class="line">│                   TLM Extensions Layer                     │</div>
<div class="line">│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐  │</div>
<div class="line">│  │    DTLS      │    │ Connection   │    │  Security    │  │</div>
<div class="line">│  │  Extension   │    │ Extension    │    │ Extension    │  │</div>
<div class="line">│  └──────────────┘    └──────────────┘    └──────────────┘  │</div>
<div class="line">├─────────────────────────────────────────────────────────────┤</div>
<div class="line">│                     Core Protocol                          │</div>
<div class="line">│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐  │</div>
<div class="line">│  │ AntiReplay   │    │  Handshake   │    │    Crypto    │  │</div>
<div class="line">│  │    Core      │    │    Core      │    │    Core      │  │</div>
<div class="line">│  └──────────────┘    └──────────────┘    └──────────────┘  │</div>
<div class="line">├─────────────────────────────────────────────────────────────┤</div>
<div class="line">│                   SystemC Adapters                         │</div>
<div class="line">│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐  │</div>
<div class="line">│  │   Timing     │    │ SystemC TLM  │    │ Performance  │  │</div>
<div class="line">│  │   Adapter    │    │   Sockets    │    │  Monitor     │  │</div>
<div class="line">│  └──────────────┘    └──────────────┘    └──────────────┘  │</div>
<div class="line">└─────────────────────────────────────────────────────────────┘</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md893"></a>
SystemC Module Hierarchy</h2>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>dtls::systemc {</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Base module for all DTLS SystemC components</span></div>
<div class="line"><span class="keyword">class </span>dtls_module_base : <span class="keyword">public</span> sc_module {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    dtls_module_base(sc_module_name name, </div>
<div class="line">                     <span class="keyword">const</span> timing_config&amp; timing = timing_config::default_config());</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Common interfaces</span></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> set_timing_model(std::shared_ptr&lt;timing_model_base&gt; <a class="code hl_variable" href="hardware__acceleration_8cpp.html#a2e5f0c4b01fa6a42a6a2215b44a116d9">model</a>) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> timing_stats get_timing_statistics() <span class="keyword">const</span> = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> reset() = 0;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    timing_config timing_cfg;</div>
<div class="line">    std::shared_ptr&lt;timing_model_base&gt; timing_model;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Timing annotation helpers</span></div>
<div class="line">    <span class="keywordtype">void</span> annotate_delay(sc_time delay);</div>
<div class="line">    <span class="keywordtype">void</span> annotate_timing_point(<span class="keyword">const</span> std::string&amp; label);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="ttc" id="ahardware__acceleration_8cpp_html_a2e5f0c4b01fa6a42a6a2215b44a116d9"><div class="ttname"><a href="hardware__acceleration_8cpp.html#a2e5f0c4b01fa6a42a6a2215b44a116d9">model</a></div><div class="ttdeci">std::string model</div><div class="ttdef"><b>Definition</b> <a href="hardware__acceleration_8cpp_source.html#l00053">hardware_acceleration.cpp:53</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md894"></a>
Core Protocol Separation Pattern</h1>
<h2><a class="anchor" id="autotoc_md895"></a>
The Logic Duplication Elimination Architecture</h2>
<p>The SystemC architecture uses a unique pattern to eliminate code duplication between the production C++ library and SystemC TLM model:</p>
<div class="fragment"><div class="line"><span class="comment">// Pure protocol core (environment-agnostic)</span></div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacedtls_1_1v13_1_1core__protocol.html">dtls::v13::core_protocol</a> {</div>
<div class="line">    <span class="keyword">class </span>AntiReplayCore {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keywordtype">bool</span> should_accept_packet(<a class="code hl_typedef" href="group__CoreTypes.html#ga50089dc7f9d67ec4e7563999a0e01a4b">SequenceNumber</a> seq_num);</div>
<div class="line">        <span class="keywordtype">void</span> record_packet(<a class="code hl_typedef" href="group__CoreTypes.html#ga50089dc7f9d67ec4e7563999a0e01a4b">SequenceNumber</a> seq_num);</div>
<div class="line">        <span class="keywordtype">void</span> <a class="code hl_function" href="classdtls_1_1v13_1_1core__protocol_1_1AntiReplayCore.html#ae9b9ffbefe06f6ce3f19516e0fc81492">reset_window</a>();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Pure algorithm implementation with no dependencies</span></div>
<div class="line">        </div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">        uint64_t window_mask_ = 0;</div>
<div class="line">        <a class="code hl_typedef" href="group__CoreTypes.html#ga50089dc7f9d67ec4e7563999a0e01a4b">SequenceNumber</a> highest_received_ = 0;</div>
<div class="line">        <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> WINDOW_SIZE = 64;</div>
<div class="line">    };</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Production adapter (C++ library)</span></div>
<div class="line"><span class="keyword">class </span>AntiReplayWindow {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    AntiReplayWindow() : core_() {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">bool</span> should_accept_packet(SequenceNumber seq_num) {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(mutex_);</div>
<div class="line">        <span class="keywordflow">return</span> core_.should_accept_packet(seq_num);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    core_protocol::AntiReplayCore core_;</div>
<div class="line">    std::mutex mutex_;  <span class="comment">// Production-specific: thread safety</span></div>
<div class="line">    <span class="comment">// Add: logging, metrics, error handling</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// SystemC adapter (TLM model)</span></div>
<div class="line"><span class="keyword">class </span>AntiReplayWindowTLM : <span class="keyword">public</span> dtls_module_base {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    AntiReplayWindowTLM(sc_module_name name) : dtls_module_base(name), core_() {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">bool</span> should_accept_packet(SequenceNumber seq_num, sc_time&amp; delay) {</div>
<div class="line">        <span class="comment">// SystemC-specific: timing annotation</span></div>
<div class="line">        delay += timing_model_-&gt;get_processing_delay(<span class="stringliteral">&quot;anti_replay_check&quot;</span>);</div>
<div class="line">        </div>
<div class="line">        <span class="keywordtype">bool</span> result = core_.should_accept_packet(seq_num);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// SystemC-specific: transaction logging</span></div>
<div class="line">        <span class="keywordflow">if</span> (enable_tracing_) {</div>
<div class="line">            log_transaction(seq_num, result);</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> result;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    core_protocol::AntiReplayCore core_;</div>
<div class="line">    <span class="keywordtype">bool</span> enable_tracing_ = <span class="keyword">false</span>;</div>
<div class="line">    <span class="comment">// Add: timing models, transaction logging, TLM interfaces</span></div>
<div class="line">};</div>
<div class="ttc" id="aclassdtls_1_1v13_1_1core__protocol_1_1AntiReplayCore_html_ae9b9ffbefe06f6ce3f19516e0fc81492"><div class="ttname"><a href="classdtls_1_1v13_1_1core__protocol_1_1AntiReplayCore.html#ae9b9ffbefe06f6ce3f19516e0fc81492">dtls::v13::core_protocol::AntiReplayCore::reset_window</a></div><div class="ttdeci">static void reset_window(WindowState &amp;state)</div><div class="ttdoc">Reset window state (for epoch changes)</div><div class="ttdef"><b>Definition</b> <a href="anti__replay__core_8cpp_source.html#l00080">anti_replay_core.cpp:80</a></div></div>
<div class="ttc" id="agroup__CoreTypes_html_ga50089dc7f9d67ec4e7563999a0e01a4b"><div class="ttname"><a href="group__CoreTypes.html#ga50089dc7f9d67ec4e7563999a0e01a4b">dtls::v13::SequenceNumber</a></div><div class="ttdeci">uint64_t SequenceNumber</div><div class="ttdoc">64-bit sequence number for replay protection.</div><div class="ttdef"><b>Definition</b> <a href="types_8h_source.html#l00047">types.h:47</a></div></div>
<div class="ttc" id="anamespacedtls_1_1v13_1_1core__protocol_html"><div class="ttname"><a href="namespacedtls_1_1v13_1_1core__protocol.html">dtls::v13::core_protocol</a></div><div class="ttdef"><b>Definition</b> <a href="anti__replay__core_8h_source.html#l00006">anti_replay_core.h:6</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md896"></a>
Benefits of Core Protocol Separation</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Benefit   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Impact    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Single Source of Truth</b>   </td><td class="markdownTableBodyNone">Protocol logic exists in exactly one place   </td><td class="markdownTableBodyNone">Zero duplication, consistent behavior    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Environment Adaptation</b>   </td><td class="markdownTableBodyNone">Each adapter adds environment-specific features   </td><td class="markdownTableBodyNone">Optimal for both production and modeling    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Independent Testing</b>   </td><td class="markdownTableBodyNone">Core logic can be unit tested without dependencies   </td><td class="markdownTableBodyNone">Higher test coverage, faster tests    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Maintainability</b>   </td><td class="markdownTableBodyNone">Protocol updates only need to be made once   </td><td class="markdownTableBodyNone">Reduced maintenance burden    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Extensibility</b>   </td><td class="markdownTableBodyNone">New environments can easily create adapters   </td><td class="markdownTableBodyNone">Future-proof architecture   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md897"></a>
Core Protocol Components</h2>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacedtls_1_1v13_1_1core__protocol.html">dtls::v13::core_protocol</a> {</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Anti-replay window management</span></div>
<div class="line"><span class="keyword">class </span>AntiReplayCore {</div>
<div class="line">    <span class="comment">// 48-bit sequence number anti-replay window</span></div>
<div class="line">    <span class="keywordtype">bool</span> should_accept_packet(<a class="code hl_typedef" href="group__CoreTypes.html#ga50089dc7f9d67ec4e7563999a0e01a4b">SequenceNumber</a> seq_num);</div>
<div class="line">    <span class="keywordtype">void</span> record_packet(<a class="code hl_typedef" href="group__CoreTypes.html#ga50089dc7f9d67ec4e7563999a0e01a4b">SequenceNumber</a> seq_num);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Handshake state machine</span></div>
<div class="line"><span class="keyword">class </span>HandshakeCore {</div>
<div class="line">    ConnectionState current_state_;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">bool</span> is_valid_transition(ConnectionState from, ConnectionState to);</div>
<div class="line">    Result&lt;ConnectionState&gt; process_message(HandshakeType type);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Cryptographic key management</span></div>
<div class="line"><span class="keyword">class </span>CryptoCore {</div>
<div class="line">    std::map&lt;Epoch, KeySet&gt; epoch_keys_;</div>
<div class="line">    </div>
<div class="line">    Result&lt;KeySet&gt; derive_keys(<span class="keyword">const</span> KeyMaterial&amp; master_secret, Epoch epoch);</div>
<div class="line">    Result&lt;void&gt; update_keys(<span class="keyword">const</span> KeyMaterial&amp; update_secret);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fragment reassembly</span></div>
<div class="line"><span class="keyword">class </span>FragmentCore {</div>
<div class="line">    std::map&lt;uint32_t, FragmentBuffer&gt; pending_fragments_;</div>
<div class="line">    </div>
<div class="line">    Result&lt;std::vector&lt;uint8_t&gt;&gt; add_fragment(<span class="keyword">const</span> Fragment&amp; fragment);</div>
<div class="line">    <span class="keywordtype">void</span> cleanup_expired_fragments();</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md898"></a>
TLM Extensions Design</h1>
<h2><a class="anchor" id="autotoc_md899"></a>
DTLS-Specific TLM Extensions</h2>
<p>Custom TLM extensions provide DTLS-specific transaction information while maintaining TLM-2.0 compliance:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>dtls::systemc {</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Primary DTLS message extension</span></div>
<div class="line"><span class="keyword">class </span>dtls_extension : <span class="keyword">public</span> tlm_extension&lt;dtls_extension&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">struct </span>dtls_message {</div>
<div class="line">        <span class="comment">// DTLS protocol fields</span></div>
<div class="line">        ContentType content_type;</div>
<div class="line">        HandshakeType handshake_type;</div>
<div class="line">        Epoch epoch;</div>
<div class="line">        SequenceNumber sequence_number;</div>
<div class="line">        std::vector&lt;uint8_t&gt; payload;</div>
<div class="line">        std::optional&lt;ConnectionID&gt; connection_id;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Security context</span></div>
<div class="line">        <span class="keywordtype">bool</span> encrypted;</div>
<div class="line">        AEADCipher cipher;</div>
<div class="line">        std::vector&lt;uint8_t&gt; auth_tag;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// SystemC timing information</span></div>
<div class="line">        sc_time arrival_time;</div>
<div class="line">        sc_time processing_deadline;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Quality of service</span></div>
<div class="line">        <span class="keyword">enum class</span> priority { LOW, NORMAL, HIGH, CRITICAL } qos_priority;</div>
<div class="line">        </div>
<div class="line">        dtls_message() : encrypted(false), qos_priority(priority::NORMAL) {}</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// TLM extension interface</span></div>
<div class="line">    dtls_extension();</div>
<div class="line">    <span class="keyword">virtual</span> ~dtls_extension();</div>
<div class="line">    <span class="keyword">virtual</span> tlm_extension_base* clone() <span class="keyword">const override</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> copy_from(<span class="keyword">const</span> tlm_extension_base&amp; ext) <span class="keyword">override</span>;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// DTLS-specific methods</span></div>
<div class="line">    <span class="keywordtype">void</span> set_message(<span class="keyword">const</span> dtls_message&amp; msg) { message_ = msg; }</div>
<div class="line">    <span class="keyword">const</span> dtls_message&amp; get_message()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> message_; }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">bool</span> is_handshake_message()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> message_.content_type == ContentType::HANDSHAKE;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">bool</span> requires_acknowledgment()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> message_.content_type == ContentType::ACK;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    dtls_message message_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Connection state extension</span></div>
<div class="line"><span class="keyword">class </span>dtls_connection_extension : <span class="keyword">public</span> tlm_extension&lt;dtls_connection_extension&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code hl_enumeration" href="namespacedtls_1_1v13.html#a68896fa2f4ab2bfbb152b31cf949f0ad">ConnectionState</a> state = ConnectionState::INITIAL;</div>
<div class="line">    std::optional&lt;ConnectionID&gt; connection_id;</div>
<div class="line">    std::optional&lt;ConnectionID&gt; peer_connection_id;</div>
<div class="line">    <a class="code hl_enumeration" href="namespacedtls_1_1v13.html#a2c8cefcd0588652f47924c24935f52e3">CipherSuite</a> negotiated_cipher_suite;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Performance metrics</span></div>
<div class="line">    <span class="keyword">struct </span>perf_metrics {</div>
<div class="line">        sc_time handshake_latency;</div>
<div class="line">        uint64_t bytes_transmitted = 0;</div>
<div class="line">        uint64_t packets_transmitted = 0;</div>
<div class="line">        uint32_t retransmission_count = 0;</div>
<div class="line">        <span class="keywordtype">double</span> throughput_mbps = 0.0;</div>
<div class="line">    } metrics;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// TLM extension interface</span></div>
<div class="line">    dtls_connection_extension();</div>
<div class="line">    <span class="keyword">virtual</span> ~dtls_connection_extension();</div>
<div class="line">    <span class="keyword">virtual</span> tlm_extension_base* clone() <span class="keyword">const override</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> copy_from(<span class="keyword">const</span> tlm_extension_base&amp; ext) <span class="keyword">override</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Security context extension</span></div>
<div class="line"><span class="keyword">class </span>dtls_security_extension : <span class="keyword">public</span> tlm_extension&lt;dtls_security_extension&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">struct </span>security_context {</div>
<div class="line">        <span class="comment">// Cryptographic state</span></div>
<div class="line">        <a class="code hl_typedef" href="group__CoreTypes.html#gace5e728a8418b8695b245902009ffa77">Epoch</a> current_epoch = 0;</div>
<div class="line">        std::map&lt;Epoch, KeyMaterial&gt; read_keys;</div>
<div class="line">        std::map&lt;Epoch, KeyMaterial&gt; write_keys;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Anti-replay window</span></div>
<div class="line">        <span class="keyword">struct </span>replay_window {</div>
<div class="line">            uint64_t window_mask = 0;</div>
<div class="line">            <a class="code hl_typedef" href="group__CoreTypes.html#ga50089dc7f9d67ec4e7563999a0e01a4b">SequenceNumber</a> highest_sequence = 0;</div>
<div class="line">            <span class="keywordtype">size_t</span> window_size = 64;</div>
<div class="line">        } anti_replay;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Security level</span></div>
<div class="line">        <a class="code hl_enumeration" href="namespacedtls_1_1v13.html#a454f2e2956822357a074530f22006b51">SecurityLevel</a> level = SecurityLevel::HIGH;</div>
<div class="line">        <span class="keywordtype">bool</span> perfect_forward_secrecy = <span class="keyword">true</span>;</div>
<div class="line">    } context;</div>
<div class="line">    </div>
<div class="line">    dtls_security_extension();</div>
<div class="line">    <span class="keyword">virtual</span> ~dtls_security_extension();</div>
<div class="line">    <span class="keyword">virtual</span> tlm_extension_base* clone() <span class="keyword">const override</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> copy_from(<span class="keyword">const</span> tlm_extension_base&amp; ext) <span class="keyword">override</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="ttc" id="agroup__CoreTypes_html_gace5e728a8418b8695b245902009ffa77"><div class="ttname"><a href="group__CoreTypes.html#gace5e728a8418b8695b245902009ffa77">dtls::v13::Epoch</a></div><div class="ttdeci">uint16_t Epoch</div><div class="ttdoc">Epoch number for key generation sequencing.</div><div class="ttdef"><b>Definition</b> <a href="types_8h_source.html#l00044">types.h:44</a></div></div>
<div class="ttc" id="anamespacedtls_1_1v13_html_a2c8cefcd0588652f47924c24935f52e3"><div class="ttname"><a href="namespacedtls_1_1v13.html#a2c8cefcd0588652f47924c24935f52e3">dtls::v13::CipherSuite</a></div><div class="ttdeci">CipherSuite</div><div class="ttdef"><b>Definition</b> <a href="types_8h_source.html#l00153">types.h:153</a></div></div>
<div class="ttc" id="anamespacedtls_1_1v13_html_a454f2e2956822357a074530f22006b51"><div class="ttname"><a href="namespacedtls_1_1v13.html#a454f2e2956822357a074530f22006b51">dtls::v13::SecurityLevel</a></div><div class="ttdeci">SecurityLevel</div><div class="ttdef"><b>Definition</b> <a href="types_8h_source.html#l00285">types.h:285</a></div></div>
<div class="ttc" id="anamespacedtls_1_1v13_html_a68896fa2f4ab2bfbb152b31cf949f0ad"><div class="ttname"><a href="namespacedtls_1_1v13.html#a68896fa2f4ab2bfbb152b31cf949f0ad">dtls::v13::ConnectionState</a></div><div class="ttdeci">ConnectionState</div><div class="ttdef"><b>Definition</b> <a href="types_8h_source.html#l00266">types.h:266</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md900"></a>
TLM Socket Design</h2>
<p>DTLS-specific TLM sockets with protocol-aware interfaces:</p>
<div class="fragment"><div class="line"><span class="comment">// DTLS initiator socket (client side)</span></div>
<div class="line"><span class="keyword">class </span>dtls_initiator_socket : <span class="keyword">public</span> tlm_initiator_socket&lt;&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    dtls_initiator_socket(<span class="keyword">const</span> <span class="keywordtype">char</span>* name = <span class="stringliteral">&quot;dtls_initiator_socket&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// DTLS-specific transport methods</span></div>
<div class="line">    sync_enum_type dtls_send(dtls_extension::dtls_message&amp; message, </div>
<div class="line">                            sc_time&amp; delay);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> dtls_send_nb(dtls_extension::dtls_message&amp; message,</div>
<div class="line">                     sc_event&amp; completion_event);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Protocol operations</span></div>
<div class="line">    <span class="keywordtype">void</span> initiate_handshake();</div>
<div class="line">    <span class="keywordtype">void</span> send_application_data(<span class="keyword">const</span> std::vector&lt;uint8_t&gt;&amp; data);</div>
<div class="line">    <span class="keywordtype">void</span> close_connection(AlertDescription alert = AlertDescription::CLOSE_NOTIFY);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Connection management</span></div>
<div class="line">    <span class="keywordtype">void</span> set_connection_id(<span class="keyword">const</span> ConnectionID&amp; cid);</div>
<div class="line">    std::optional&lt;ConnectionID&gt; get_connection_id() <span class="keyword">const</span>;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> enable_early_data(<span class="keywordtype">bool</span> enable);</div>
<div class="line">    <span class="keywordtype">bool</span> is_early_data_enabled() <span class="keyword">const</span>;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::unique_ptr&lt;dtls_transport_if&gt; transport_impl;</div>
<div class="line">    std::optional&lt;ConnectionID&gt; connection_id_;</div>
<div class="line">    <span class="keywordtype">bool</span> early_data_enabled_ = <span class="keyword">false</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// DTLS target socket (server side)</span></div>
<div class="line"><span class="keyword">class </span>dtls_target_socket : <span class="keyword">public</span> tlm_target_socket&lt;&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    dtls_target_socket(<span class="keyword">const</span> <span class="keywordtype">char</span>* name = <span class="stringliteral">&quot;dtls_target_socket&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// TLM-2.0 interface implementation</span></div>
<div class="line">    <span class="keyword">virtual</span> sync_enum_type nb_transport_fw(tlm_generic_payload&amp; payload,</div>
<div class="line">                                          tlm_phase&amp; phase,</div>
<div class="line">                                          sc_time&amp; delay) <span class="keyword">override</span>;</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> b_transport(tlm_generic_payload&amp; payload,</div>
<div class="line">                           sc_time&amp; delay) <span class="keyword">override</span>;</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> get_direct_mem_ptr(tlm_generic_payload&amp; payload,</div>
<div class="line">                                  tlm_dmi&amp; dmi_data) <span class="keyword">override</span>;</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> transport_dbg(tlm_generic_payload&amp; payload) <span class="keyword">override</span>;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// DTLS-specific callbacks</span></div>
<div class="line">    <span class="keywordtype">void</span> register_handshake_callback(</div>
<div class="line">        std::function&lt;<span class="keywordtype">void</span>(<span class="keyword">const</span> dtls_extension::dtls_message&amp;)&gt; callback);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> register_data_callback(</div>
<div class="line">        std::function&lt;<span class="keywordtype">void</span>(<span class="keyword">const</span> std::vector&lt;uint8_t&gt;&amp;)&gt; callback);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> register_error_callback(</div>
<div class="line">        std::function&lt;<span class="keywordtype">void</span>(<span class="keyword">const</span> std::string&amp;)&gt; callback);</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::function&lt;void(<span class="keyword">const</span> dtls_extension::dtls_message&amp;)&gt; handshake_cb;</div>
<div class="line">    std::function&lt;void(<span class="keyword">const</span> std::vector&lt;uint8_t&gt;&amp;)&gt; data_cb;</div>
<div class="line">    std::function&lt;void(<span class="keyword">const</span> std::string&amp;)&gt; error_cb;</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md901"></a>
Timing Models Architecture</h1>
<h2><a class="anchor" id="autotoc_md902"></a>
Configurable Timing Framework</h2>
<p>The SystemC implementation provides multiple timing models for different simulation needs:</p>
<div class="fragment"><div class="line"><span class="comment">// Base timing model interface</span></div>
<div class="line"><span class="keyword">class </span>timing_model_base {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> ~timing_model_base() = <span class="keywordflow">default</span>;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Core timing methods</span></div>
<div class="line">    <span class="keyword">virtual</span> sc_time get_handshake_latency(HandshakeType type) <span class="keyword">const</span> = 0;</div>
<div class="line">    <span class="keyword">virtual</span> sc_time get_crypto_operation_latency(<span class="keyword">const</span> std::string&amp; operation,</div>
<div class="line">                                                <span class="keywordtype">size_t</span> data_size) <span class="keyword">const</span> = 0;</div>
<div class="line">    <span class="keyword">virtual</span> sc_time get_record_processing_latency(<span class="keywordtype">size_t</span> record_size) <span class="keyword">const</span> = 0;</div>
<div class="line">    <span class="keyword">virtual</span> sc_time get_network_transmission_latency(<span class="keywordtype">size_t</span> data_size) <span class="keyword">const</span> = 0;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Advanced timing</span></div>
<div class="line">    <span class="keyword">virtual</span> sc_time get_power_on_latency() <span class="keyword">const</span> = 0;</div>
<div class="line">    <span class="keyword">virtual</span> sc_time get_context_switch_latency() <span class="keyword">const</span> = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> get_power_consumption(<span class="keyword">const</span> std::string&amp; operation) <span class="keyword">const</span> = 0;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Configuration</span></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> set_clock_frequency(<span class="keywordtype">double</span> freq_mhz) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> set_memory_latency(sc_time latency) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> enable_power_modeling(<span class="keywordtype">bool</span> enable) = 0;</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md903"></a>
Timing Model Implementations</h2>
<h3><a class="anchor" id="autotoc_md904"></a>
1. Approximate Timing Model (Fast Simulation)</h3>
<div class="fragment"><div class="line"><span class="keyword">class </span>approximate_timing_model : <span class="keyword">public</span> timing_model_base {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">struct </span>approximate_timing_config {</div>
<div class="line">        sc_time base_handshake_latency = sc_time(10, SC_MS);</div>
<div class="line">        sc_time base_crypto_latency = sc_time(100, SC_US);</div>
<div class="line">        sc_time base_record_latency = sc_time(10, SC_US);</div>
<div class="line">        sc_time base_network_latency = sc_time(1, SC_MS);</div>
<div class="line">        </div>
<div class="line">        <span class="keywordtype">double</span> crypto_scaling_factor = 1.0;    <span class="comment">// per byte</span></div>
<div class="line">        <span class="keywordtype">double</span> network_scaling_factor = 0.001; <span class="comment">// per byte</span></div>
<div class="line">        </div>
<div class="line">        <span class="keyword">static</span> approximate_timing_config fast_simulation_config();</div>
<div class="line">        <span class="keyword">static</span> approximate_timing_config default_config();</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    approximate_timing_model(<span class="keyword">const</span> approximate_timing_config&amp; config);</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">virtual</span> sc_time get_handshake_latency(HandshakeType type)<span class="keyword"> const override </span>{</div>
<div class="line">        <span class="keywordflow">switch</span> (type) {</div>
<div class="line">            <span class="keywordflow">case</span> HandshakeType::CLIENT_HELLO:</div>
<div class="line">                <span class="keywordflow">return</span> config_.base_handshake_latency * 0.8;</div>
<div class="line">            <span class="keywordflow">case</span> HandshakeType::SERVER_HELLO:</div>
<div class="line">                <span class="keywordflow">return</span> config_.base_handshake_latency * 1.2;</div>
<div class="line">            <span class="keywordflow">case</span> HandshakeType::FINISHED:</div>
<div class="line">                <span class="keywordflow">return</span> config_.base_handshake_latency * 0.5;</div>
<div class="line">            <span class="keywordflow">default</span>:</div>
<div class="line">                <span class="keywordflow">return</span> config_.base_handshake_latency;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">virtual</span> sc_time get_crypto_operation_latency(<span class="keyword">const</span> std::string&amp; operation,</div>
<div class="line">                                                <span class="keywordtype">size_t</span> data_size)<span class="keyword"> const override </span>{</div>
<div class="line">        sc_time base_latency = config_.base_crypto_latency;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (operation == <span class="stringliteral">&quot;aes_encrypt&quot;</span> || operation == <span class="stringliteral">&quot;aes_decrypt&quot;</span>) {</div>
<div class="line">            base_latency *= 0.8;  <span class="comment">// Hardware acceleration</span></div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (operation == <span class="stringliteral">&quot;rsa_sign&quot;</span> || operation == <span class="stringliteral">&quot;rsa_verify&quot;</span>) {</div>
<div class="line">            base_latency *= 3.0;  <span class="comment">// Expensive operations</span></div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> base_latency + sc_time(data_size * config_.crypto_scaling_factor, SC_NS);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    approximate_timing_config config_;</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md905"></a>
2. Cycle-Accurate Timing Model (Detailed Simulation)</h3>
<div class="fragment"><div class="line"><span class="keyword">class </span>cycle_accurate_timing_model : <span class="keyword">public</span> timing_model_base {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">struct </span>cycle_accurate_config {</div>
<div class="line">        <span class="keywordtype">double</span> cpu_frequency_mhz = 1000.0;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Cache configuration</span></div>
<div class="line">        <span class="keyword">struct </span>cache_config {</div>
<div class="line">            sc_time l1_hit_latency = sc_time(1, SC_NS);</div>
<div class="line">            sc_time l2_hit_latency = sc_time(10, SC_NS);</div>
<div class="line">            sc_time l3_hit_latency = sc_time(30, SC_NS);</div>
<div class="line">            sc_time main_memory_latency = sc_time(100, SC_NS);</div>
<div class="line">        } cache;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Crypto unit configuration</span></div>
<div class="line">        <span class="keyword">struct </span>crypto_unit_config {</div>
<div class="line">            sc_time aes_setup_latency = sc_time(50, SC_NS);</div>
<div class="line">            sc_time aes_per_block_latency = sc_time(5, SC_NS);</div>
<div class="line">            sc_time hash_per_block_latency = sc_time(3, SC_NS);</div>
<div class="line">            sc_time rng_latency = sc_time(100, SC_NS);</div>
<div class="line">        } crypto_unit;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Network interface configuration</span></div>
<div class="line">        <span class="keyword">struct </span>network_config {</div>
<div class="line">            <span class="keywordtype">double</span> bandwidth_mbps = 1000.0;  <span class="comment">// 1 Gbps</span></div>
<div class="line">            sc_time packet_processing_latency = sc_time(1, SC_US);</div>
<div class="line">            sc_time interrupt_latency = sc_time(500, SC_NS);</div>
<div class="line">        } network;</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">static</span> cycle_accurate_config arm_cortex_a75_config();</div>
<div class="line">        <span class="keyword">static</span> cycle_accurate_config intel_xeon_config();</div>
<div class="line">        <span class="keyword">static</span> cycle_accurate_config embedded_config();</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    cycle_accurate_timing_model(<span class="keyword">const</span> cycle_accurate_config&amp; config);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Hardware-specific timing</span></div>
<div class="line">    sc_time get_cache_access_latency(cache_level level, cache_access_type type) <span class="keyword">const</span>;</div>
<div class="line">    sc_time get_instruction_execution_latency(instruction_type instr) <span class="keyword">const</span>;</div>
<div class="line">    sc_time get_memory_access_latency(memory_type mem_type, <span class="keywordtype">size_t</span> size) <span class="keyword">const</span>;</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">virtual</span> sc_time get_crypto_operation_latency(<span class="keyword">const</span> std::string&amp; operation,</div>
<div class="line">                                                <span class="keywordtype">size_t</span> data_size)<span class="keyword"> const override </span>{</div>
<div class="line">        sc_time total_latency = config_.crypto_unit.aes_setup_latency;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (operation == <span class="stringliteral">&quot;aes_encrypt&quot;</span> || operation == <span class="stringliteral">&quot;aes_decrypt&quot;</span>) {</div>
<div class="line">            <span class="keywordtype">size_t</span> blocks = (data_size + 15) / 16;  <span class="comment">// AES block size</span></div>
<div class="line">            total_latency += config_.crypto_unit.aes_per_block_latency * blocks;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Add cache access latencies</span></div>
<div class="line">        total_latency += get_cache_access_latency(CACHE_L1, CACHE_READ);</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> total_latency;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    cycle_accurate_config config_;</div>
<div class="line">    <span class="keyword">mutable</span> std::map&lt;std::string, sc_time&gt; operation_cache_;</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md906"></a>
Power Modeling Extension</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>power_model {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">struct </span>power_config {</div>
<div class="line">        <span class="keywordtype">double</span> voltage_v = 1.2;</div>
<div class="line">        <span class="keywordtype">double</span> temperature_c = 25.0;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Component power characteristics</span></div>
<div class="line">        <span class="keyword">struct </span>component_power {</div>
<div class="line">            <span class="keywordtype">double</span> static_power_mw = 100.0;</div>
<div class="line">            <span class="keywordtype">double</span> dynamic_power_per_mhz_mw = 0.1;</div>
<div class="line">            <span class="keywordtype">double</span> leakage_coefficient = 0.01;</div>
<div class="line">        };</div>
<div class="line">        </div>
<div class="line">        component_power cpu_core;</div>
<div class="line">        component_power crypto_unit;</div>
<div class="line">        component_power memory_controller;</div>
<div class="line">        component_power network_interface;</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">static</span> power_config mobile_config();</div>
<div class="line">        <span class="keyword">static</span> power_config server_config();</div>
<div class="line">        <span class="keyword">static</span> power_config iot_config();</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    power_model(<span class="keyword">const</span> power_config&amp; config);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Power consumption estimation</span></div>
<div class="line">    <span class="keywordtype">double</span> get_static_power_mw() <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">double</span> get_dynamic_power_mw(<span class="keyword">const</span> std::string&amp; operation, </div>
<div class="line">                               <span class="keywordtype">double</span> activity_factor) <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">double</span> get_leakage_power_mw() <span class="keyword">const</span>;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Energy consumption</span></div>
<div class="line">    <span class="keywordtype">double</span> get_operation_energy_uj(<span class="keyword">const</span> std::string&amp; operation, </div>
<div class="line">                                  sc_time duration) <span class="keyword">const</span>;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    power_config config_;</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md907"></a>
Communication Channels</h1>
<h2><a class="anchor" id="autotoc_md908"></a>
DTLS Message Channels</h2>
<div class="fragment"><div class="line"><span class="comment">// DTLS message channel with flow control</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = dtls_extension::dtls_message&gt;</div>
<div class="line"><span class="keyword">class </span>dtls_message_channel : <span class="keyword">public</span> sc_channel, </div>
<div class="line">                            <span class="keyword">public</span> tlm_fifo_get_if&lt;T&gt;,</div>
<div class="line">                            <span class="keyword">public</span> tlm_fifo_put_if&lt;T&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">explicit</span> dtls_message_channel(<span class="keywordtype">size_t</span> size = 16);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// TLM FIFO interface</span></div>
<div class="line">    <span class="keyword">virtual</span> T get(tlm_tag&lt;T&gt;* = <span class="keyword">nullptr</span>) <span class="keyword">override</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> nb_get(T&amp; val) <span class="keyword">override</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> nb_can_get(tlm_tag&lt;T&gt;* = <span class="keyword">nullptr</span>) <span class="keyword">const override</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keyword">const</span> sc_event&amp; ok_to_get(tlm_tag&lt;T&gt;* = <span class="keyword">nullptr</span>) <span class="keyword">const override</span>;</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> put(<span class="keyword">const</span> T&amp; val) <span class="keyword">override</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> nb_put(<span class="keyword">const</span> T&amp; val) <span class="keyword">override</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> nb_can_put(tlm_tag&lt;T&gt;* = <span class="keyword">nullptr</span>) <span class="keyword">const override</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keyword">const</span> sc_event&amp; ok_to_put(tlm_tag&lt;T&gt;* = <span class="keyword">nullptr</span>) <span class="keyword">const override</span>;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// DTLS-specific methods</span></div>
<div class="line">    <span class="keywordtype">void</span> set_priority_filter(std::function&lt;<span class="keywordtype">bool</span>(<span class="keyword">const</span> T&amp;)&gt; filter);</div>
<div class="line">    <span class="keywordtype">void</span> enable_flow_control(<span class="keywordtype">bool</span> enable);</div>
<div class="line">    <span class="keywordtype">void</span> set_backpressure_threshold(<span class="keywordtype">size_t</span> threshold);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Statistics</span></div>
<div class="line">    <span class="keyword">struct </span>channel_stats {</div>
<div class="line">        uint64_t messages_sent = 0;</div>
<div class="line">        uint64_t messages_received = 0;</div>
<div class="line">        uint64_t messages_dropped = 0;</div>
<div class="line">        uint64_t backpressure_events = 0;</div>
<div class="line">        sc_time total_latency;</div>
<div class="line">        <span class="keywordtype">size_t</span> peak_usage = 0;</div>
<div class="line">    } statistics;</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">const</span> channel_stats&amp; get_statistics()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> statistics_; }</div>
<div class="line">    <span class="keywordtype">void</span> reset_statistics() { statistics_ = channel_stats{}; }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::queue&lt;T&gt; queue_;</div>
<div class="line">    <span class="keywordtype">size_t</span> max_size_;</div>
<div class="line">    <span class="keyword">mutable</span> sc_event ok_to_get_event_;</div>
<div class="line">    <span class="keyword">mutable</span> sc_event ok_to_put_event_;</div>
<div class="line">    std::function&lt;bool(<span class="keyword">const</span> T&amp;)&gt; priority_filter_;</div>
<div class="line">    <span class="keywordtype">bool</span> flow_control_enabled_ = <span class="keyword">false</span>;</div>
<div class="line">    <span class="keywordtype">size_t</span> backpressure_threshold_;</div>
<div class="line">    channel_stats statistics_;</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md909"></a>
Network Simulation Channel</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>network_channel : <span class="keyword">public</span> sc_channel {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">struct </span>network_config {</div>
<div class="line">        <span class="keywordtype">double</span> bandwidth_mbps = 100.0;</div>
<div class="line">        sc_time propagation_delay = sc_time(1, SC_MS);</div>
<div class="line">        <span class="keywordtype">double</span> packet_loss_rate = 0.001;  <span class="comment">// 0.1%</span></div>
<div class="line">        sc_time jitter_max = sc_time(100, SC_US);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Quality of Service</span></div>
<div class="line">        <span class="keywordtype">bool</span> enable_qos = <span class="keyword">true</span>;</div>
<div class="line">        <span class="keywordtype">size_t</span> max_queue_size = 1000;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Error simulation</span></div>
<div class="line">        <span class="keywordtype">bool</span> enable_error_injection = <span class="keyword">false</span>;</div>
<div class="line">        <span class="keywordtype">double</span> bit_error_rate = 1e-9;</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">static</span> network_config lan_config();</div>
<div class="line">        <span class="keyword">static</span> network_config wan_config();</div>
<div class="line">        <span class="keyword">static</span> network_config wireless_config();</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    network_channel(sc_module_name name, <span class="keyword">const</span> network_config&amp; config);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Network interface</span></div>
<div class="line">    <span class="keywordtype">void</span> send_packet(<span class="keyword">const</span> std::vector&lt;uint8_t&gt;&amp; packet, </div>
<div class="line">                    <span class="keyword">const</span> NetworkAddress&amp; dest,</div>
<div class="line">                    packet_priority priority = packet_priority::NORMAL);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> register_receiver(<span class="keyword">const</span> NetworkAddress&amp; addr,</div>
<div class="line">                          std::function&lt;<span class="keywordtype">void</span>(<span class="keyword">const</span> std::vector&lt;uint8_t&gt;&amp;)&gt; callback);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Configuration</span></div>
<div class="line">    <span class="keywordtype">void</span> set_network_config(<span class="keyword">const</span> network_config&amp; config);</div>
<div class="line">    network_config get_network_config()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> config_; }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Statistics and monitoring</span></div>
<div class="line">    <span class="keyword">struct </span>network_stats {</div>
<div class="line">        uint64_t packets_sent = 0;</div>
<div class="line">        uint64_t packets_received = 0;</div>
<div class="line">        uint64_t packets_dropped = 0;</div>
<div class="line">        uint64_t packets_corrupted = 0;</div>
<div class="line">        uint64_t bytes_transmitted = 0;</div>
<div class="line">        sc_time total_latency;</div>
<div class="line">        <span class="keywordtype">double</span> current_utilization = 0.0;</div>
<div class="line">    } statistics;</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">const</span> network_stats&amp; get_statistics()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> statistics_; }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    SC_HAS_PROCESS(network_channel);</div>
<div class="line">    <span class="keywordtype">void</span> network_thread();</div>
<div class="line">    <span class="keywordtype">void</span> packet_corruption_thread();</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    network_config config_;</div>
<div class="line">    std::map&lt;NetworkAddress, std::function&lt;void(<span class="keyword">const</span> std::vector&lt;uint8_t&gt;&amp;)&gt;&gt; receivers_;</div>
<div class="line">    std::queue&lt;network_packet&gt; packet_queue_;</div>
<div class="line">    network_stats statistics_;</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">struct </span>network_packet {</div>
<div class="line">        std::vector&lt;uint8_t&gt; <a class="code hl_variable" href="namespacedtls_1_1v13_1_1crypto.html#a54dd791091de8efe4b57d9d26e14a2f2">data</a>;</div>
<div class="line">        NetworkAddress source;</div>
<div class="line">        NetworkAddress <a class="code hl_variable" href="namespacedtls_1_1v13_1_1memory_1_1utils.html#a5da6b7d0d20688d166ff3b9f280cdfac">destination</a>;</div>
<div class="line">        packet_priority priority;</div>
<div class="line">        sc_time timestamp;</div>
<div class="line">    };</div>
<div class="line">};</div>
<div class="ttc" id="anamespacedtls_1_1v13_1_1crypto_html_a54dd791091de8efe4b57d9d26e14a2f2"><div class="ttname"><a href="namespacedtls_1_1v13_1_1crypto.html#a54dd791091de8efe4b57d9d26e14a2f2">dtls::v13::crypto::data</a></div><div class="ttdeci">__attribute__((visibility(&quot;default&quot;))) Result&lt; std __attribute__((visibility(&quot;default&quot;))) Result&lt; memory __attribute__((visibility(&quot;default&quot;))) Result&lt; memory __attribute__((visibility(&quot;default&quot;))) Result&lt; std __attribute__((visibility(&quot;default&quot;))) Result&lt; std __attribute__((visibility(&quot;default&quot;))) Result&lt; std __attribute__((visibility(&quot;default&quot;))) Result&lt; std __attribute__((visibility(&quot;default&quot;))) Result&lt; std __attribute__((visibility(&quot;default&quot;))) Result&lt; std const void * data</div><div class="ttdef"><b>Definition</b> <a href="hash_8h_source.html#l00109">hash.h:109</a></div></div>
<div class="ttc" id="anamespacedtls_1_1v13_1_1memory_1_1utils_html_a5da6b7d0d20688d166ff3b9f280cdfac"><div class="ttname"><a href="namespacedtls_1_1v13_1_1memory_1_1utils.html#a5da6b7d0d20688d166ff3b9f280cdfac">dtls::v13::memory::utils::destination</a></div><div class="ttdeci">MutableBufferView &amp; destination</div><div class="ttdef"><b>Definition</b> <a href="memory__utils_8h_source.html#l00132">memory_utils.h:132</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md910"></a>
Testbench Architecture</h1>
<h2><a class="anchor" id="autotoc_md911"></a>
Protocol Verification Testbench</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>dtls_protocol_testbench : <span class="keyword">public</span> sc_module {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    dtls_protocol_testbench(sc_module_name name, <span class="keyword">const</span> testbench_config&amp; config);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Test components</span></div>
<div class="line">    std::unique_ptr&lt;dtls_protocol_stack&gt; client_stack;</div>
<div class="line">    std::unique_ptr&lt;dtls_protocol_stack&gt; server_stack;</div>
<div class="line">    std::unique_ptr&lt;network_channel&gt; network;</div>
<div class="line">    std::unique_ptr&lt;test_traffic_generator&gt; traffic_gen;</div>
<div class="line">    std::unique_ptr&lt;test_monitor&gt; monitor;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Test execution</span></div>
<div class="line">    <span class="keywordtype">void</span> run_test_suite();</div>
<div class="line">    <span class="keywordtype">void</span> run_single_test(<span class="keyword">const</span> std::string&amp; test_name);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Test cases</span></div>
<div class="line">    <span class="keywordtype">void</span> test_basic_handshake();</div>
<div class="line">    <span class="keywordtype">void</span> test_session_resumption();</div>
<div class="line">    <span class="keywordtype">void</span> test_early_data();</div>
<div class="line">    <span class="keywordtype">void</span> test_connection_id_migration();</div>
<div class="line">    <span class="keywordtype">void</span> test_key_update();</div>
<div class="line">    <span class="keywordtype">void</span> test_error_recovery();</div>
<div class="line">    <span class="keywordtype">void</span> test_dos_protection();</div>
<div class="line">    <span class="keywordtype">void</span> test_interoperability();</div>
<div class="line">    <span class="keywordtype">void</span> test_performance_regression();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Configuration</span></div>
<div class="line">    <span class="keyword">struct </span>testbench_config {</div>
<div class="line">        <span class="comment">// Test selection</span></div>
<div class="line">        std::set&lt;std::string&gt; enabled_tests;</div>
<div class="line">        <span class="keywordtype">bool</span> run_all_tests = <span class="keyword">true</span>;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Simulation parameters</span></div>
<div class="line">        sc_time simulation_timeout = sc_time(10, SC_SEC);</div>
<div class="line">        <span class="keywordtype">bool</span> enable_logging = <span class="keyword">true</span>;</div>
<div class="line">        <span class="keywordtype">bool</span> enable_waveform_dump = <span class="keyword">false</span>;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Test data generation</span></div>
<div class="line">        <span class="keyword">struct </span>traffic_config {</div>
<div class="line">            <span class="keywordtype">size_t</span> min_message_size = 64;</div>
<div class="line">            <span class="keywordtype">size_t</span> max_message_size = 1500;</div>
<div class="line">            <span class="keywordtype">double</span> message_rate_hz = 100.0;</div>
<div class="line">            <span class="keywordtype">size_t</span> total_messages = 1000;</div>
<div class="line">        } traffic;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Network simulation</span></div>
<div class="line">        network_channel::network_config network;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Coverage collection</span></div>
<div class="line">        <span class="keywordtype">bool</span> enable_coverage = <span class="keyword">true</span>;</div>
<div class="line">        std::string coverage_db_path = <span class="stringliteral">&quot;coverage.db&quot;</span>;</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">static</span> testbench_config regression_config();</div>
<div class="line">        <span class="keyword">static</span> testbench_config performance_config();</div>
<div class="line">        <span class="keyword">static</span> testbench_config debug_config();</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Test results</span></div>
<div class="line">    <span class="keyword">struct </span>test_results {</div>
<div class="line">        <span class="keyword">struct </span>test_case_result {</div>
<div class="line">            std::string name;</div>
<div class="line">            <span class="keywordtype">bool</span> passed;</div>
<div class="line">            std::string failure_reason;</div>
<div class="line">            sc_time execution_time;</div>
<div class="line">            std::map&lt;std::string, double&gt; metrics;</div>
<div class="line">        };</div>
<div class="line">        </div>
<div class="line">        std::vector&lt;test_case_result&gt; test_cases;</div>
<div class="line">        <span class="keywordtype">size_t</span> total_tests = 0;</div>
<div class="line">        <span class="keywordtype">size_t</span> passed_tests = 0;</div>
<div class="line">        <span class="keywordtype">size_t</span> failed_tests = 0;</div>
<div class="line">        sc_time total_execution_time;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordtype">void</span> print_summary() <span class="keyword">const</span>;</div>
<div class="line">        <span class="keywordtype">void</span> save_to_file(<span class="keyword">const</span> std::string&amp; filename) <span class="keyword">const</span>;</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    test_results get_test_results()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> results_; }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    SC_HAS_PROCESS(dtls_protocol_testbench);</div>
<div class="line">    <span class="keywordtype">void</span> test_runner_thread();</div>
<div class="line">    <span class="keywordtype">void</span> timeout_monitor_thread();</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    testbench_config config_;</div>
<div class="line">    test_results results_;</div>
<div class="line">    sc_event test_complete_event_;</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md912"></a>
Performance Analysis Framework</h1>
<h2><a class="anchor" id="autotoc_md913"></a>
Performance Monitoring Architecture</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>performance_analyzer : <span class="keyword">public</span> sc_module {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    performance_analyzer(sc_module_name name);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Monitoring interfaces</span></div>
<div class="line">    <span class="keywordtype">void</span> register_protocol_stack(dtls_protocol_stack* stack, <span class="keyword">const</span> std::string&amp; name);</div>
<div class="line">    <span class="keywordtype">void</span> register_network_channel(network_channel* channel, <span class="keyword">const</span> std::string&amp; name);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Analysis methods</span></div>
<div class="line">    <span class="keywordtype">void</span> start_analysis();</div>
<div class="line">    <span class="keywordtype">void</span> stop_analysis();</div>
<div class="line">    <span class="keywordtype">void</span> generate_report();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Performance metrics</span></div>
<div class="line">    <span class="keyword">struct </span>performance_metrics {</div>
<div class="line">        <span class="comment">// Throughput metrics</span></div>
<div class="line">        <span class="keywordtype">double</span> peak_throughput_mbps;</div>
<div class="line">        <span class="keywordtype">double</span> average_throughput_mbps;</div>
<div class="line">        <span class="keywordtype">double</span> min_throughput_mbps;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Latency metrics</span></div>
<div class="line">        sc_time peak_latency;</div>
<div class="line">        sc_time average_latency;</div>
<div class="line">        sc_time min_latency;</div>
<div class="line">        sc_time p99_latency;  <span class="comment">// 99th percentile</span></div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Handshake performance</span></div>
<div class="line">        sc_time average_handshake_time;</div>
<div class="line">        <span class="keywordtype">double</span> handshake_success_rate;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Resource utilization</span></div>
<div class="line">        <span class="keywordtype">double</span> cpu_utilization;</div>
<div class="line">        <span class="keywordtype">double</span> memory_utilization;</div>
<div class="line">        <span class="keywordtype">double</span> network_utilization;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Power consumption</span></div>
<div class="line">        <span class="keywordtype">double</span> average_power_mw;</div>
<div class="line">        <span class="keywordtype">double</span> peak_power_mw;</div>
<div class="line">        <span class="keywordtype">double</span> total_energy_mj;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Error rates</span></div>
<div class="line">        <span class="keywordtype">double</span> packet_loss_rate;</div>
<div class="line">        <span class="keywordtype">double</span> retransmission_rate;</div>
<div class="line">        <span class="keywordtype">double</span> crypto_error_rate;</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    performance_metrics get_current_metrics() <span class="keyword">const</span>;</div>
<div class="line">    std::vector&lt;performance_metrics&gt; get_historical_metrics() <span class="keyword">const</span>;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Bottleneck analysis</span></div>
<div class="line">    <span class="keyword">struct </span>bottleneck_analysis {</div>
<div class="line">        <span class="keyword">enum class</span> bottleneck_type {</div>
<div class="line">            CPU_BOUND, MEMORY_BOUND, NETWORK_BOUND, </div>
<div class="line">            CRYPTO_BOUND, PROTOCOL_BOUND</div>
<div class="line">        } primary_bottleneck;</div>
<div class="line">        </div>
<div class="line">        std::map&lt;std::string, double&gt; component_utilization;</div>
<div class="line">        std::vector&lt;std::string&gt; optimization_suggestions;</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    bottleneck_analysis analyze_bottlenecks() <span class="keyword">const</span>;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Comparison and regression analysis</span></div>
<div class="line">    <span class="keyword">struct </span>comparison_result {</div>
<div class="line">        <span class="keywordtype">double</span> throughput_improvement_percent;</div>
<div class="line">        sc_time latency_improvement;</div>
<div class="line">        <span class="keywordtype">double</span> power_efficiency_improvement;</div>
<div class="line">        <span class="keywordtype">bool</span> performance_regression_detected;</div>
<div class="line">        std::vector&lt;std::string&gt; regression_details;</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    comparison_result compare_with_baseline(<span class="keyword">const</span> performance_metrics&amp; baseline) <span class="keyword">const</span>;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Report generation</span></div>
<div class="line">    <span class="keywordtype">void</span> save_metrics_csv(<span class="keyword">const</span> std::string&amp; filename) <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">void</span> save_performance_report(<span class="keyword">const</span> std::string&amp; filename) <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">void</span> generate_plots(<span class="keyword">const</span> std::string&amp; output_dir) <span class="keyword">const</span>;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    SC_HAS_PROCESS(performance_analyzer);</div>
<div class="line">    <span class="keywordtype">void</span> monitoring_thread();</div>
<div class="line">    <span class="keywordtype">void</span> analysis_thread();</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">struct </span>monitored_stack {</div>
<div class="line">        dtls_protocol_stack* stack;</div>
<div class="line">        std::string name;</div>
<div class="line">        std::vector&lt;performance_metrics&gt; history;</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">struct </span>monitored_channel {</div>
<div class="line">        network_channel* channel;</div>
<div class="line">        std::string name;</div>
<div class="line">        std::vector&lt;network_channel::network_stats&gt; history;</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    std::vector&lt;monitored_stack&gt; protocol_stacks_;</div>
<div class="line">    std::vector&lt;monitored_channel&gt; network_channels_;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">bool</span> analyzing_ = <span class="keyword">false</span>;</div>
<div class="line">    sc_time analysis_interval_ = sc_time(100, SC_MS);</div>
<div class="line">    performance_metrics current_metrics_;</div>
<div class="line">    std::vector&lt;performance_metrics&gt; historical_metrics_;</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md914"></a>
Hardware/Software Co-design</h1>
<h2><a class="anchor" id="autotoc_md915"></a>
Hardware Acceleration Modeling</h2>
<div class="fragment"><div class="line"><span class="comment">// Hardware crypto accelerator model</span></div>
<div class="line"><span class="keyword">class </span>hardware_crypto_accelerator : <span class="keyword">public</span> sc_module {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    hardware_crypto_accelerator(sc_module_name name, <span class="keyword">const</span> hw_config&amp; config);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// TLM sockets</span></div>
<div class="line">    tlm_target_socket&lt;&gt; crypto_request_socket;</div>
<div class="line">    tlm_initiator_socket&lt;&gt; crypto_response_socket;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Hardware interface signals</span></div>
<div class="line">    sc_in&lt;bool&gt; clk;</div>
<div class="line">    sc_in&lt;bool&gt; reset_n;</div>
<div class="line">    sc_out&lt;bool&gt; busy;</div>
<div class="line">    sc_out&lt;bool&gt; interrupt;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Configuration</span></div>
<div class="line">    <span class="keyword">struct </span>hw_config {</div>
<div class="line">        <span class="comment">// Performance characteristics</span></div>
<div class="line">        sc_time aes_latency_per_block = sc_time(5, SC_NS);</div>
<div class="line">        sc_time rsa_latency_2048 = sc_time(50, SC_US);</div>
<div class="line">        sc_time hash_latency_per_block = sc_time(3, SC_NS);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Power characteristics</span></div>
<div class="line">        <span class="keywordtype">double</span> active_power_mw = 500.0;</div>
<div class="line">        <span class="keywordtype">double</span> idle_power_mw = 50.0;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Capacity limits</span></div>
<div class="line">        uint32_t max_concurrent_operations = 8;</div>
<div class="line">        <span class="keywordtype">size_t</span> max_key_size = 4096;</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">static</span> hw_config fpga_config();</div>
<div class="line">        <span class="keyword">static</span> hw_config asic_config();</div>
<div class="line">        <span class="keyword">static</span> hw_config dedicated_chip_config();</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// TLM transport implementation</span></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> b_transport(tlm_generic_payload&amp; payload, sc_time&amp; delay) <span class="keyword">override</span>;</div>
<div class="line">    <span class="keyword">virtual</span> sync_enum_type nb_transport_fw(tlm_generic_payload&amp; payload,</div>
<div class="line">                                          tlm_phase&amp; phase,</div>
<div class="line">                                          sc_time&amp; delay) <span class="keyword">override</span>;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Hardware-specific methods</span></div>
<div class="line">    <span class="keywordtype">void</span> process_crypto_operation(<span class="keyword">const</span> crypto_request&amp; request);</div>
<div class="line">    <span class="keywordtype">void</span> generate_interrupt();</div>
<div class="line">    <span class="keywordtype">double</span> get_current_power_consumption() <span class="keyword">const</span>;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    SC_HAS_PROCESS(hardware_crypto_accelerator);</div>
<div class="line">    <span class="keywordtype">void</span> crypto_processing_thread();</div>
<div class="line">    <span class="keywordtype">void</span> power_management_thread();</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    hw_config config_;</div>
<div class="line">    std::queue&lt;crypto_request&gt; request_queue_;</div>
<div class="line">    std::atomic&lt;uint32_t&gt; active_operations_{0};</div>
<div class="line">    <span class="keywordtype">double</span> current_power_consumption_ = 0.0;</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md916"></a>
Software Stack Integration</h2>
<div class="fragment"><div class="line"><span class="comment">// Software stack running on embedded processor</span></div>
<div class="line"><span class="keyword">class </span>embedded_software_stack : <span class="keyword">public</span> sc_module {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    embedded_software_stack(sc_module_name name, <span class="keyword">const</span> sw_config&amp; config);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Processor interface</span></div>
<div class="line">    tlm_initiator_socket&lt;&gt; processor_bus;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Hardware accelerator interface</span></div>
<div class="line">    tlm_initiator_socket&lt;&gt; hw_crypto_socket;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Configuration</span></div>
<div class="line">    <span class="keyword">struct </span>sw_config {</div>
<div class="line">        <span class="comment">// Processor characteristics</span></div>
<div class="line">        <span class="keywordtype">double</span> cpu_frequency_mhz = 400.0;</div>
<div class="line">        <span class="keywordtype">size_t</span> cache_size_kb = 32;</div>
<div class="line">        <span class="keywordtype">size_t</span> ram_size_mb = 16;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Operating system</span></div>
<div class="line">        sc_time context_switch_latency = sc_time(10, SC_US);</div>
<div class="line">        sc_time interrupt_latency = sc_time(1, SC_US);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Software stack configuration</span></div>
<div class="line">        <span class="keywordtype">bool</span> enable_hw_crypto_offload = <span class="keyword">true</span>;</div>
<div class="line">        <span class="keywordtype">size_t</span> sw_crypto_fallback_threshold = 1024;  <span class="comment">// bytes</span></div>
<div class="line">        </div>
<div class="line">        <span class="keyword">static</span> sw_config cortex_m7_config();</div>
<div class="line">        <span class="keyword">static</span> sw_config arm_a53_config();</div>
<div class="line">        <span class="keyword">static</span> sw_config risc_v_config();</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Software processes</span></div>
<div class="line">    <span class="keywordtype">void</span> dtls_protocol_task();</div>
<div class="line">    <span class="keywordtype">void</span> crypto_management_task();</div>
<div class="line">    <span class="keywordtype">void</span> network_interface_task();</div>
<div class="line">    <span class="keywordtype">void</span> system_monitoring_task();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Hardware/software coordination</span></div>
<div class="line">    <span class="keywordtype">void</span> offload_crypto_operation(<span class="keyword">const</span> crypto_request&amp; request);</div>
<div class="line">    <span class="keywordtype">bool</span> should_use_hardware_crypto(<span class="keyword">const</span> crypto_request&amp; request) <span class="keyword">const</span>;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    SC_HAS_PROCESS(embedded_software_stack);</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    sw_config config_;</div>
<div class="line">    std::queue&lt;crypto_request&gt; sw_crypto_queue_;</div>
<div class="line">    std::queue&lt;crypto_request&gt; hw_crypto_queue_;</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md917"></a>
Conclusion</h1>
<p>The SystemC architecture provides:</p>
<h2><a class="anchor" id="autotoc_md918"></a>
Key SystemC Architecture Benefits</h2>
<ol type="1">
<li><b>TLM-2.0 Compliance</b>: Standard interfaces enable tool interoperability</li>
<li><b>Logic Duplication Elimination</b>: 80%+ code reuse between C++ and SystemC</li>
<li><b>Configurable Timing Models</b>: From approximate to cycle-accurate simulation</li>
<li><b>Protocol-Specific Extensions</b>: DTLS-aware TLM transactions</li>
<li><b>Comprehensive Testbench</b>: Complete verification infrastructure</li>
<li><b>Performance Analysis</b>: Detailed metrics and bottleneck identification</li>
<li><b>Hardware/Software Co-design</b>: Full system modeling capability</li>
</ol>
<h2><a class="anchor" id="autotoc_md919"></a>
Architecture Success Metrics</h2>
<ul>
<li><b>Code Reuse</b>: 80%+ of protocol logic shared with C++ implementation</li>
<li><b>Timing Accuracy</b>: Configurable from approximate to cycle-accurate</li>
<li><b>TLM Compliance</b>: Full TLM-2.0 standard compliance</li>
<li><b>Performance Modeling</b>: Accurate throughput and latency simulation</li>
<li><b>Verification Coverage</b>: Comprehensive protocol and security validation</li>
</ul>
<p>The SystemC architecture enables both hardware/software co-design and system-level verification while maintaining the same high standards of security, performance, and RFC 9147 compliance as the production C++ implementation. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
