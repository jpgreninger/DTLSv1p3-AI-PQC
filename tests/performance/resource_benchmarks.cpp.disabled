/*
 * DTLS v1.3 Resource Utilization Benchmarks
 * Task 10: Performance Benchmarking - Memory and CPU Usage Tests
 */

#include "benchmark_framework.h"
#include <dtls/connection/advanced_connection_manager.h>
#include <dtls/types.h> // Contains CipherSuite enum
#include "../test_infrastructure/test_certificates.h"
#include "../test_infrastructure/mock_transport.h"
#include <chrono>
#include <thread>
#include <vector>
#include <memory>
#include <algorithm>

namespace dtls::v13::test::performance {

// ============================================================================
// MemoryBenchmark Implementation
// ============================================================================

class MemoryBenchmark::Impl {
public:
    BenchmarkConfig config_;
    size_t connection_count_ = 1;
    bool memory_tracking_enabled_ = true;
    
    std::unique_ptr<test::infrastructure::TestCertificates> test_certs_;
    std::unique_ptr<test::infrastructure::MockTransport> mock_transport_;
    std::vector<std::shared_ptr<connection::Connection>> active_connections_;
    
    Impl(const BenchmarkConfig& config) : config_(config) {
        setup_test_infrastructure();
    }
    
    void setup_test_infrastructure() {
        test_certs_ = std::make_unique<test::infrastructure::TestCertificates>();
        mock_transport_ = std::make_unique<test::infrastructure::MockTransport>();
        
        mock_transport_->set_packet_loss_rate(0.0);
        mock_transport_->set_network_delay(std::chrono::microseconds(10));
    }
    
    BenchmarkResult benchmark_connection_memory_usage_impl() {
        BenchmarkRunner runner(config_);
        ResourceMonitor monitor;
        
        size_t baseline_memory = 0;
        size_t peak_connection_memory = 0;
        
        runner.register_benchmark("Connection Memory Usage", [this, &monitor, &peak_connection_memory]() {
            monitor.start_monitoring();
            
            // Create connections
            create_test_connections(connection_count_);
            
            // Allow time for full initialization
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
            
            peak_connection_memory = monitor.get_peak_memory_usage();
            monitor.stop_monitoring();
            
            cleanup_test_connections();
        }, [this, &monitor, &baseline_memory]() {
            // Measure baseline memory before creating connections
            monitor.start_monitoring();
            std::this_thread::sleep_for(std::chrono::milliseconds(50));
            baseline_memory = monitor.get_average_memory_usage();
            monitor.stop_monitoring();
            monitor.reset();
        });
        
        auto results = runner.run_all_benchmarks();
        if (!results.empty()) {
            auto& result = results[0];
            
            // Calculate memory overhead per connection
            size_t memory_overhead = peak_connection_memory > baseline_memory ? 
                peak_connection_memory - baseline_memory : 0;
            size_t memory_per_connection = connection_count_ > 0 ? 
                memory_overhead / connection_count_ : 0;
            
            result.peak_memory_bytes = peak_connection_memory;
            result.avg_memory_bytes = memory_overhead;
            result.custom_metrics["baseline_memory_bytes"] = static_cast<double>(baseline_memory);
            result.custom_metrics["memory_overhead_bytes"] = static_cast<double>(memory_overhead);
            result.custom_metrics["memory_per_connection_bytes"] = static_cast<double>(memory_per_connection);
            result.custom_metrics["memory_per_connection_kb"] = static_cast<double>(memory_per_connection) / 1024.0;
            
            // PRD compliance check
            size_t memory_overhead_mb = memory_overhead / (1024 * 1024);
            result.meets_memory_requirement = memory_overhead_mb <= 10; // 10MB limit from PRD
            
            return result;
        }
        
        return BenchmarkResult{};
    }
    
    BenchmarkResult benchmark_handshake_memory_overhead_impl() {
        BenchmarkRunner runner(config_);
        
        std::vector<size_t> memory_samples;
        size_t baseline_memory = 0;
        
        runner.register_benchmark("Handshake Memory Overhead", [this, &memory_samples]() {
            ResourceMonitor monitor;
            monitor.start_monitoring();
            
            // Perform handshake
            auto [client, server] = create_connection_pair();
            complete_handshake(client, server);
            
            memory_samples.push_back(monitor.get_peak_memory_usage());
            monitor.stop_monitoring();
            
            cleanup_connection_pair(client, server);
        }, [this, &baseline_memory]() {
            baseline_memory = measure_baseline_memory();
        });
        
        auto results = runner.run_all_benchmarks();
        if (!results.empty()) {
            auto& result = results[0];
            
            if (!memory_samples.empty()) {
                auto max_memory = *std::max_element(memory_samples.begin(), memory_samples.end());
                auto avg_memory = std::accumulate(memory_samples.begin(), memory_samples.end(), 0ULL) / memory_samples.size();
                
                result.peak_memory_bytes = max_memory;
                result.avg_memory_bytes = avg_memory;
                result.custom_metrics["baseline_memory_bytes"] = static_cast<double>(baseline_memory);
                result.custom_metrics["handshake_overhead_peak"] = static_cast<double>(max_memory - baseline_memory);
                result.custom_metrics["handshake_overhead_avg"] = static_cast<double>(avg_memory - baseline_memory);
            }
            
            return result;
        }
        
        return BenchmarkResult{};
    }
    
    BenchmarkResult benchmark_crypto_memory_usage_impl() {
        BenchmarkRunner runner(config_);
        
        std::vector<size_t> crypto_memory_samples;
        
        runner.register_benchmark("Crypto Memory Usage", [this, &crypto_memory_samples]() {
            ResourceMonitor monitor;
            monitor.start_monitoring();
            
            // Perform cryptographic operations
            perform_crypto_operations();
            
            crypto_memory_samples.push_back(monitor.get_peak_memory_usage());
            monitor.stop_monitoring();
        });
        
        auto results = runner.run_all_benchmarks();
        if (!results.empty()) {
            auto& result = results[0];
            
            if (!crypto_memory_samples.empty()) {
                auto max_crypto_memory = *std::max_element(crypto_memory_samples.begin(), crypto_memory_samples.end());
                auto avg_crypto_memory = std::accumulate(crypto_memory_samples.begin(), crypto_memory_samples.end(), 0ULL) / crypto_memory_samples.size();
                
                result.peak_memory_bytes = max_crypto_memory;
                result.avg_memory_bytes = avg_crypto_memory;
                result.custom_metrics["crypto_operations_count"] = config_.iterations;
            }
            
            return result;
        }
        
        return BenchmarkResult{};
    }
    
    BenchmarkResult benchmark_buffer_management_impl() {
        BenchmarkRunner runner(config_);
        
        std::vector<size_t> buffer_memory_samples;
        std::vector<size_t> data_sizes = {1024, 4096, 16384, 65536};
        
        runner.register_benchmark("Buffer Management", [this, &buffer_memory_samples, &data_sizes]() {
            ResourceMonitor monitor;
            
            for (size_t data_size : data_sizes) {
                monitor.start_monitoring();
                
                // Create and manage buffers
                auto [client, server] = create_connection_pair();
                complete_handshake(client, server);
                
                // Transfer data to test buffer management
                std::vector<uint8_t> test_data = generate_test_data(data_size);
                client->send_application_data(test_data);
                
                mock_transport_->process_pending_messages();
                server->process_incoming_data();
                server->receive_application_data();
                
                buffer_memory_samples.push_back(monitor.get_peak_memory_usage());
                monitor.stop_monitoring();
                monitor.reset();
                
                cleanup_connection_pair(client, server);
            }
        });
        
        auto results = runner.run_all_benchmarks();
        if (!results.empty()) {
            auto& result = results[0];
            
            if (!buffer_memory_samples.empty()) {
                auto max_buffer_memory = *std::max_element(buffer_memory_samples.begin(), buffer_memory_samples.end());
                auto avg_buffer_memory = std::accumulate(buffer_memory_samples.begin(), buffer_memory_samples.end(), 0ULL) / buffer_memory_samples.size();
                
                result.peak_memory_bytes = max_buffer_memory;
                result.avg_memory_bytes = avg_buffer_memory;
                
                // Calculate memory scaling with data size
                if (buffer_memory_samples.size() >= 2) {
                    size_t memory_growth = buffer_memory_samples.back() - buffer_memory_samples.front();
                    size_t data_growth = data_sizes.back() - data_sizes.front();
                    double memory_scaling_factor = static_cast<double>(memory_growth) / data_growth;
                    result.custom_metrics["memory_scaling_factor"] = memory_scaling_factor;
                }
            }
            
            return result;
        }
        
        return BenchmarkResult{};
    }
    
    BenchmarkResult benchmark_memory_leaks_impl() {
        BenchmarkRunner runner(config_);
        
        std::vector<size_t> memory_progression;
        
        runner.register_benchmark("Memory Leak Detection", [this, &memory_progression]() {
            ResourceMonitor monitor;
            
            for (size_t cycle = 0; cycle < 10; ++cycle) {
                monitor.start_monitoring();
                
                // Create and destroy connections repeatedly
                for (size_t i = 0; i < 5; ++i) {
                    auto [client, server] = create_connection_pair();
                    complete_handshake(client, server);
                    
                    // Transfer some data
                    std::vector<uint8_t> test_data = generate_test_data(1024);
                    client->send_application_data(test_data);
                    mock_transport_->process_pending_messages();
                    server->process_incoming_data();
                    server->receive_application_data();
                    
                    cleanup_connection_pair(client, server);
                }
                
                memory_progression.push_back(monitor.get_peak_memory_usage());
                monitor.stop_monitoring();
                monitor.reset();
                
                // Force garbage collection if available
                std::this_thread::sleep_for(std::chrono::milliseconds(100));
            }
        });
        
        auto results = runner.run_all_benchmarks();
        if (!results.empty()) {
            auto& result = results[0];
            
            if (memory_progression.size() >= 2) {
                size_t initial_memory = memory_progression.front();
                size_t final_memory = memory_progression.back();
                
                result.peak_memory_bytes = *std::max_element(memory_progression.begin(), memory_progression.end());
                result.avg_memory_bytes = std::accumulate(memory_progression.begin(), memory_progression.end(), 0ULL) / memory_progression.size();
                
                // Calculate memory growth trend
                double memory_growth = static_cast<double>(final_memory - initial_memory);
                double growth_rate = memory_growth / initial_memory * 100.0;
                
                result.custom_metrics["initial_memory_bytes"] = static_cast<double>(initial_memory);
                result.custom_metrics["final_memory_bytes"] = static_cast<double>(final_memory);
                result.custom_metrics["memory_growth_bytes"] = memory_growth;
                result.custom_metrics["memory_growth_rate_percent"] = growth_rate;
                
                // Check for potential memory leaks (>10% growth)
                bool potential_leak = growth_rate > 10.0;
                result.custom_metrics["potential_memory_leak"] = potential_leak ? 1.0 : 0.0;
                
                if (potential_leak) {
                    result.error_count = 1;
                    result.error_rate = 1.0;
                }
            }
            
            return result;
        }
        
        return BenchmarkResult{};
    }
    
private:
    void create_test_connections(size_t count) {
        auto client_config = create_client_config();
        auto server_config = create_server_config();
        
        for (size_t i = 0; i < count; ++i) {
            connection::ConnectionManager client_manager(client_config);
            connection::ConnectionManager server_manager(server_config);
            
            std::string endpoint_name = "endpoint_" + std::to_string(i);
            auto client_endpoint = mock_transport_->create_endpoint(endpoint_name + "_client");
            auto server_endpoint = mock_transport_->create_endpoint(endpoint_name + "_server");
            mock_transport_->connect_endpoints(client_endpoint, server_endpoint);
            
            auto client_conn = client_manager.create_connection(client_endpoint);
            auto server_conn = server_manager.accept_connection(server_endpoint);
            
            complete_handshake(client_conn, server_conn);
            
            active_connections_.push_back(client_conn);
            active_connections_.push_back(server_conn);
        }
    }
    
    void cleanup_test_connections() {
        for (auto& conn : active_connections_) {
            if (conn) {
                conn->close();
            }
        }
        active_connections_.clear();
        mock_transport_->reset();
    }
    
    std::pair<std::shared_ptr<connection::Connection>, std::shared_ptr<connection::Connection>> 
    create_connection_pair() {
        auto client_config = create_client_config();
        auto server_config = create_server_config();
        
        connection::ConnectionManager client_manager(client_config);
        connection::ConnectionManager server_manager(server_config);
        
        auto client_endpoint = mock_transport_->create_endpoint("client");
        auto server_endpoint = mock_transport_->create_endpoint("server");
        mock_transport_->connect_endpoints(client_endpoint, server_endpoint);
        
        auto client_conn = client_manager.create_connection(client_endpoint);
        auto server_conn = server_manager.accept_connection(server_endpoint);
        
        return {client_conn, server_conn};
    }
    
    void cleanup_connection_pair(std::shared_ptr<connection::Connection> client,
                               std::shared_ptr<connection::Connection> server) {
        if (client) client->close();
        if (server) server->close();
        mock_transport_->reset();
    }
    
    void complete_handshake(std::shared_ptr<connection::Connection> client,
                           std::shared_ptr<connection::Connection> server) {
        const size_t max_iterations = 20;
        size_t iteration = 0;
        
        while ((!client->is_handshake_complete() || !server->is_handshake_complete()) && 
               iteration < max_iterations) {
            
            mock_transport_->process_pending_messages();
            client->process_incoming_data();
            server->process_incoming_data();
            
            iteration++;
            std::this_thread::sleep_for(std::chrono::microseconds(10));
        }
        
        if (!client->is_handshake_complete() || !server->is_handshake_complete()) {
            throw std::runtime_error("Handshake failed to complete for memory test");
        }
    }
    
    size_t measure_baseline_memory() {
        ResourceMonitor monitor;
        monitor.start_monitoring();
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        size_t baseline = monitor.get_average_memory_usage();
        monitor.stop_monitoring();
        return baseline;
    }
    
    void perform_crypto_operations() {
        // Perform various cryptographic operations to measure memory usage
        auto client_config = create_client_config();
        auto server_config = create_server_config();
        
        // Create multiple cipher suites
        std::vector<uint16_t> cipher_suites = {0x1301, 0x1302, 0x1303};
        
        for (uint16_t suite : cipher_suites) {
            client_config.cipher_suites = {suite};
            server_config.cipher_suites = {suite};
            
            connection::ConnectionManager client_manager(client_config);
            connection::ConnectionManager server_manager(server_config);
            
            auto client_endpoint = mock_transport_->create_endpoint("crypto_client");
            auto server_endpoint = mock_transport_->create_endpoint("crypto_server");
            mock_transport_->connect_endpoints(client_endpoint, server_endpoint);
            
            auto client_conn = client_manager.create_connection(client_endpoint);
            auto server_conn = server_manager.accept_connection(server_endpoint);
            
            complete_handshake(client_conn, server_conn);
            
            // Perform data encryption/decryption
            std::vector<uint8_t> test_data = generate_test_data(4096);
            client_conn->send_application_data(test_data);
            mock_transport_->process_pending_messages();
            server_conn->process_incoming_data();
            server_conn->receive_application_data();
            
            cleanup_connection_pair(client_conn, server_conn);
        }
    }
    
    connection::ClientConfig create_client_config() {
        connection::ClientConfig config;
        config.protocol_version = protocol::ProtocolVersion::DTLS_1_3;
        config.cipher_suites = {0x1301};
        config.supported_groups = {"secp256r1"};
        config.verify_certificate = false;
        return config;
    }
    
    connection::ServerConfig create_server_config() {
        connection::ServerConfig config;
        config.protocol_version = protocol::ProtocolVersion::DTLS_1_3;
        config.cipher_suites = {0x1301};
        config.supported_groups = {"secp256r1"};
        config.certificate_chain = test_certs_->get_certificate_chain(1);
        config.private_key = test_certs_->get_private_key();
        return config;
    }
};

// ============================================================================
// Public MemoryBenchmark Interface
// ============================================================================

MemoryBenchmark::MemoryBenchmark(const BenchmarkConfig& config) 
    : pimpl_(std::make_unique<Impl>(config)) {}

BenchmarkResult MemoryBenchmark::benchmark_connection_memory_usage() {
    return pimpl_->benchmark_connection_memory_usage_impl();
}

BenchmarkResult MemoryBenchmark::benchmark_handshake_memory_overhead() {
    return pimpl_->benchmark_handshake_memory_overhead_impl();
}

BenchmarkResult MemoryBenchmark::benchmark_crypto_memory_usage() {
    return pimpl_->benchmark_crypto_memory_usage_impl();
}

BenchmarkResult MemoryBenchmark::benchmark_buffer_management() {
    return pimpl_->benchmark_buffer_management_impl();
}

BenchmarkResult MemoryBenchmark::benchmark_memory_leaks() {
    return pimpl_->benchmark_memory_leaks_impl();
}

void MemoryBenchmark::set_connection_count(size_t count) {
    pimpl_->connection_count_ = count;
}

void MemoryBenchmark::enable_memory_tracking(bool enabled) {
    pimpl_->memory_tracking_enabled_ = enabled;
}

// ============================================================================
// Comprehensive Resource Performance Test Suite
// ============================================================================

class ResourcePerformanceTestSuite {
public:
    explicit ResourcePerformanceTestSuite(const BenchmarkConfig& config = BenchmarkConfig{}) 
        : config_(config), memory_benchmark_(config) {}
    
    std::vector<BenchmarkResult> run_all_resource_benchmarks() {
        std::vector<BenchmarkResult> results;
        
        // Basic memory usage tests
        std::cout << "Running memory usage benchmarks..." << std::endl;
        
        // Test different connection counts
        for (size_t conn_count : {1, 10, 50, 100}) {
            memory_benchmark_.set_connection_count(conn_count);
            auto result = memory_benchmark_.benchmark_connection_memory_usage();
            result.name += "_" + std::to_string(conn_count) + "_connections";
            results.push_back(result);
        }
        
        // Handshake memory overhead
        std::cout << "Running handshake memory overhead benchmark..." << std::endl;
        results.push_back(memory_benchmark_.benchmark_handshake_memory_overhead());
        
        // Crypto memory usage
        std::cout << "Running crypto memory usage benchmark..." << std::endl;
        results.push_back(memory_benchmark_.benchmark_crypto_memory_usage());
        
        // Buffer management
        std::cout << "Running buffer management benchmark..." << std::endl;
        results.push_back(memory_benchmark_.benchmark_buffer_management());
        
        // Memory leak detection
        std::cout << "Running memory leak detection..." << std::endl;
        results.push_back(memory_benchmark_.benchmark_memory_leaks());
        
        return results;
    }
    
    void generate_resource_summary(const std::vector<BenchmarkResult>& results, std::ostream& output) {
        output << "\nResource Utilization Summary\n";
        output << "===========================\n\n";
        
        // Memory analysis
        size_t total_peak_memory = 0;
        size_t total_avg_memory = 0;
        size_t test_count = 0;
        
        for (const auto& result : results) {
            if (result.peak_memory_bytes > 0) {
                total_peak_memory += result.peak_memory_bytes;
                total_avg_memory += result.avg_memory_bytes;
                test_count++;
            }
        }
        
        if (test_count > 0) {
            output << "Memory Usage:\n";
            output << "  Average Peak Memory: " << (total_peak_memory / test_count / 1024) << " KB\n";
            output << "  Average Memory Usage: " << (total_avg_memory / test_count / 1024) << " KB\n";
            
            // Find peak memory test
            auto max_memory_it = std::max_element(results.begin(), results.end(),
                [](const BenchmarkResult& a, const BenchmarkResult& b) {
                    return a.peak_memory_bytes < b.peak_memory_bytes;
                });
            
            if (max_memory_it != results.end()) {
                output << "  Peak Memory Test: " << max_memory_it->name 
                       << " (" << (max_memory_it->peak_memory_bytes / 1024) << " KB)\n";
            }
        }
        
        // CPU analysis
        double total_cpu = 0.0;
        size_t cpu_test_count = 0;
        
        for (const auto& result : results) {
            if (result.avg_cpu_percent > 0) {
                total_cpu += result.avg_cpu_percent;
                cpu_test_count++;
            }
        }
        
        if (cpu_test_count > 0) {
            output << "\nCPU Usage:\n";
            output << "  Average CPU Usage: " << (total_cpu / cpu_test_count) << "%\n";
            
            auto max_cpu_it = std::max_element(results.begin(), results.end(),
                [](const BenchmarkResult& a, const BenchmarkResult& b) {
                    return a.avg_cpu_percent < b.avg_cpu_percent;
                });
            
            if (max_cpu_it != results.end()) {
                output << "  Peak CPU Test: " << max_cpu_it->name 
                       << " (" << max_cpu_it->avg_cpu_percent << "%)\n";
            }
        }
        
        // Memory leak analysis
        for (const auto& result : results) {
            if (result.name.find("Memory Leak") != std::string::npos) {
                auto leak_metric = result.custom_metrics.find("potential_memory_leak");
                if (leak_metric != result.custom_metrics.end() && leak_metric->second > 0) {
                    output << "\n⚠️  Potential memory leak detected in: " << result.name << "\n";
                    
                    auto growth_metric = result.custom_metrics.find("memory_growth_rate_percent");
                    if (growth_metric != result.custom_metrics.end()) {
                        output << "   Memory growth rate: " << growth_metric->second << "%\n";
                    }
                }
            }
        }
        
        // PRD compliance summary
        size_t memory_compliant = std::count_if(results.begin(), results.end(),
            [](const BenchmarkResult& result) {
                return result.meets_memory_requirement;
            });
        
        size_t cpu_compliant = std::count_if(results.begin(), results.end(),
            [](const BenchmarkResult& result) {
                return result.meets_cpu_requirement;
            });
        
        output << "\nPRD Compliance:\n";
        output << "  Memory Requirements: " << memory_compliant << "/" << results.size() << " tests passed\n";
        output << "  CPU Requirements: " << cpu_compliant << "/" << results.size() << " tests passed\n";
    }
    
private:
    BenchmarkConfig config_;
    MemoryBenchmark memory_benchmark_;
};

} // namespace dtls::v13::test::performance